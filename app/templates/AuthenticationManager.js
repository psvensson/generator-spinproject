// Generated by CoffeeScript 1.9.3
(function() {
  var AuthenticationManager, ClientEndpoints, Cookies, DB, OStore, QPUser, debug, defer, passport, redis, session, util, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  uuid = require('node-uuid');

  defer = require('node-promise').defer;

  util = require('util');

  OStore = require('spincycle').OStore;

  DB = require('spincycle').DB;

  QPUser = require('./server//QPUser');

  ClientEndpoints = require('spincycle').ClientEndpoints;

  passport = require('passport');

  Cookies = require('cookies');

  session = require('express-session');

  redis = require('redis');

  debug = process.env["DEBUG"];

  AuthenticationManager = (function() {
    function AuthenticationManager(app) {
      this.app = app;
      this.canUserListTheseObjects = bind(this.canUserListTheseObjects, this);
      this.canUserCreateThisObject = bind(this.canUserCreateThisObject, this);
      this.canUserWriteToThisObject = bind(this.canUserWriteToThisObject, this);
      this.canUserReadFromThisObject = bind(this.canUserReadFromThisObject, this);
      this.onDisconnect = bind(this.onDisconnect, this);
      this.getAnonymousUser = bind(this.getAnonymousUser, this);
      this.decorateMessageWithUser = bind(this.decorateMessageWithUser, this);
      this.setPublicGame = bind(this.setPublicGame, this);
      this.onLogoutUser = bind(this.onLogoutUser, this);
      this.isUserAdmin = bind(this.isUserAdmin, this);
      this.allowUser = bind(this.allowUser, this);
      this.finishLogin = bind(this.finishLogin, this);
      this.decorateUserWith = bind(this.decorateUserWith, this);
      this.onLogin = bind(this.onLogin, this);
      this.sendUserFromSessionId = bind(this.sendUserFromSessionId, this);
      this.onGetUserFromSessionId = bind(this.onGetUserFromSessionId, this);
      this.onGetUser = bind(this.onGetUser, this);
      this.onRegisterAuthCallback = bind(this.onRegisterAuthCallback, this);
      this.setup = bind(this.setup, this);
      this.setQpSettings = bind(this.setQpSettings, this);
      this.getContent = bind(this.getContent, this);
      console.log('---------------------------------------------------------- AuthMgr constructor');
      this.admins = ['psvensson@gmail.com'];
      this.anonymousUsers = [];
      ClientEndpoints.onDisconnect(this.onDisconnect);
      this.sessions = [];
      passport.serializeUser = function(user, done) {
        var localuser, ref, ref1, ref2;
        if (user) {
          console.log('passport serializeuser called');
          console.dir(user);
          localuser = {
            providerId: user.id,
            displayName: user.displayName,
            name: user.name,
            gender: user.gender,
            profileUrl: user.profileUrl || ((ref = user._json) != null ? ref.link : void 0),
            picture: (ref1 = user._json) != null ? ref1.picture : void 0,
            provider: user.provider,
            email: (ref2 = user._json) != null ? ref2.email : void 0
          };
          return new QPUser(localuser).then((function(_this) {
            return function(user) {
              user.serialize();
              return done(null, user);
            };
          })(this));
        }
      };
      passport.deserializeUser(function(user, done) {
        return DB.get('QPUser', [user.id]).then(function(dbuser) {
          return done(null, dbuser[0]);
        });
      });
    }

    AuthenticationManager.prototype.getContent = function(url) {
      var lib, q, request;
      q = defer();
      lib = url.startsWith('https') ? require('https') : require('http');
      request = lib.get(url, (function(_this) {
        return function(response) {
          var body;
          if (response.statusCode < 200 || response.statusCode > 299) {
            console.dir(response.headers);
            return q.reject(new Error('Failed to load page, status code: ' + response.statusCode));
          } else {
            body = [];
            response.on('data', function(chunk) {
              return body.push(chunk);
            });
            return response.on('end', function() {
              return q.resolve(body.join(''));
            });
          }
        };
      })(this));
      request.on('error', (function(_this) {
        return function(err) {
          console.log('getContent got error ' + err);
          return q.reject(err);
        };
      })(this));
      return q;
    };

    AuthenticationManager.prototype.setQpSettings = function(settings) {
      this.settings = settings;
      console.log('authmgr.setGeSettings qpsettings are');
      return console.dir(this.settings);
    };

    AuthenticationManager.prototype.setup = function(messageRouter) {
      this.messageRouter = messageRouter;
      console.log('---------------------------------------------------------- AuthMgr setup messageRouter = ' + this.messageRouter);
      this.activeUsers = [];
      this.replyCallbacks = [];
      this.messageRouter.addTarget('getCurrentUser', '<none>', this.onGetUser);
      this.messageRouter.addTarget('getUserFromSessionId', 'sessionId', this.onGetUserFromSessionId);
      this.messageRouter.addTarget('logoutUser', 'sessionId', this.onLogoutUser);
      return this.messageRouter.addTarget('login', 'access_token', this.onLogin);
    };

    AuthenticationManager.prototype.onRegisterAuthCallback = function(msg) {
      return this.replyCallbacks[msg.uuid] = msg;
    };

    AuthenticationManager.prototype.onGetUser = function(msg) {
      var tc, user, userobj;
      console.log('onGetUser called');
      user = this.activeUsers[msg.sessionId];
      if (user) {
        return OStore.getObject(user.id, user.type).then((function(_this) {
          return function(userobj) {
            var cbmsg, muuid, tc;
            muuid = msg.uuid;
            if (muuid) {
              cbmsg = _this.replyCallbacks[muuid];
              if (cbmsg) {
                delete _this.replyCallbacks[muuid];
                cbmsg.replyFunc({
                  user: userobj.toClient()
                });
              }
            }
            tc = userobj.toClient();
            tc.admin = userobj.isAdmin;
            tc.sessionId = userobj.sid;
            console.log('========================================= getUser return ' + JSON.stringify(tc));
            if (userobj) {
              return msg.replyFunc({
                status: 'SUCCESS',
                info: 'user profile',
                payload: tc
              });
            }
          };
        })(this));
      } else {
        userobj = this.anonymousUsers[msg.client];
        if (userobj) {
          tc = userobj.toClient();
          tc.admin = userobj.isAdmin;
          tc.sessionId = userobj.sid;
          console.log('========================================= getUser return anonymous ' + JSON.stringify(tc));
          return msg.replyFunc({
            status: 'SUCCESS',
            info: 'user profile',
            payload: tc
          });
        } else {
          return msg.replyFunc({
            status: 'SUCCESS',
            info: 'null user profile',
            payload: {}
          });
        }
      }
    };

    AuthenticationManager.prototype.onGetUserFromSessionId = function(msg) {
      var obj;
      console.log('onGetUserFromSessionId called');
      if (msg.sessionId) {
        obj = this.activeUsers[msg.sessionId];
        if (obj) {
          console.log('found user in activeUsers cache');
          return this.sendUserFromSessionId(msg, obj.id);
        } else {
          return DB.findMany('QPUser', 'sessionId', msg.sessionId).then((function(_this) {
            return function(urecords) {
              if (urecords && urecords[0]) {
                console.log('found user for sessionid in DB');
                return _this.sendUserFromSessionId(msg, urecords[0].id);
              } else {
                console.log('could not find user for sessionId ' + msg.sessionId);
                return msg.replyFunc({
                  status: 'FAILURE',
                  info: 'onGetUserFromSessionId: no user for sessionId',
                  payload: null
                });
              }
            };
          })(this));
        }
      } else {
        return msg.replyFunc({
          status: 'FAILURE',
          info: 'onGetUserFromSessionId: missing parameter',
          payload: null
        });
      }
    };

    AuthenticationManager.prototype.sendUserFromSessionId = function(msg, uid) {
      console.log('sendUserFromSessionId resolving user with id ' + uid);
      return DB.getFromStoreOrDB('QPUser', uid).then((function(_this) {
        return function(userobj) {
          var tc;
          console.log('found user');
          tc = userobj.toClient();
          tc.admin = userobj.isAdmin;
          console.log(JSON.stringify(tc));
          return msg.replyFunc({
            status: 'SUCCESS',
            info: 'user profile',
            payload: tc
          });
        };
      })(this));
    };

    "createUser: (localuser, msg) =>\n  DB.byProviderId('Player', localuser.providerId).then (dbuser) =>\n    console.log 'on authenticate query for got back user '+dbuser\n    if debug then console.dir dbuser\n    if dbuser\n      localuser = dbuser\n      console.log '-- Found existing user with id '+localuser.id+' and provider id '+localuser.providerId\n    else\n      console.log '-- Found no existing user with provider id '+localuser.providerId\n    localuser.lastLogin = new Date()+\"\"\n    localuser.type = 'Player'\n    OStore.getOrCreateObjectFromRecord(localuser).then (userobj) =>\n      @finishLogin(userobj, msg)";

    AuthenticationManager.prototype.onLogin = function(msg) {
      console.log('Login called. access_token = ' + msg.access_token);
      if (msg.access_token) {
        return this.getContent('https://qp1.eu.auth0.com/userinfo/?access_token=' + msg.access_token).then((function(_this) {
          return function(_uprofile) {
            var uprofile;
            uprofile = JSON.parse(_uprofile);
            console.log('auth0 userinfo returns');
            console.dir(uprofile);
            return DB.findMany('QPUser', 'email', uprofile.email).then(function(urecords) {
              console.log('result of finding existing user with email ' + uprofile.email + ' is ' + urecords);
              console.dir(urecords);
              if (urecords && urecords[0]) {
                return DB.getFromStoreOrDB('QPUser', urecords[0].id).then(function(userobj) {
                  return _this.finishLogin(userobj, uprofile, msg);
                });
              } else {
                return new QPUser(uprofile).then(function(newuserobj) {
                  return _this.finishLogin(newuserobj, uprofile, msg);
                });
              }
            });
          };
        })(this));
      } else {
        console.log('missing access_token!!!');
        console.dir(msg);
        return msg.replyFunc({
          status: 'FAILURE',
          info: 'onLogin: missing parameter access_token',
          payload: null
        });
      }
    };

    AuthenticationManager.prototype.decorateUserWith = function(userobj, uprofile) {
      userobj.cdata = uprofile.cdata || {};
      userobj.displayname = uprofile.displayName || ' ';
      userobj.name = uprofile.displayName || uprofile.name;
      userobj.profileUrl = uprofile.profileUrl || ' ';
      userobj.picture = uprofile.picture;
      userobj.email = uprofile.email;
      return userobj;
    };

    AuthenticationManager.prototype.finishLogin = function(_userobj, uprofile, msg) {
      var oldu, sid, userobj;
      userobj = this.decorateUserWith(_userobj, uprofile);
      userobj.nologins++;
      userobj.lastLogin = Date.now();
      oldu = this.activeUsers[sid];
      if (oldu) {
        userobj.sessionId = oldu.sid;
        sid = oldu.sid;
      } else {
        sid = uuid.v4();
        userobj.sessionId = sid;
      }
      return userobj.serialize().then((function(_this) {
        return function() {
          var toclient;
          console.log('------------------------------------------------------------------ finishLogin called for user ' + userobj.email + ' with picture ' + userobj.picture + ' and sessionId ' + userobj.sessionId);
          _this.activeUsers[sid] = userobj;
          toclient = userobj.toClient();
          toclient.sid = sid;
          if (userobj.isAdmin) {
            toclient.admin = true;
          }
          if (_this.allowUser(userobj)) {
            console.log('user logged in successfully: ' + toclient.email);
            _this.activeUsers[msg.sessionId] = userobj;
            console.log('admin = ' + toclient.admin);
            console.dir(toclient);
            return msg.replyFunc({
              status: 'SUCCESS',
              info: 'user profile',
              payload: toclient
            });
          } else {
            console.log('user not allowed to login: ' + toclient.email);
            return msg.replyFunc({
              status: 'FAILURE',
              info: 'user not allowed to log in (email address or domain restrictions)',
              payload: toclient.email
            });
          }
        };
      })(this));
    };

    AuthenticationManager.prototype.allowUser = function(userobj) {
      var domains, rv;
      rv = (this.settings.users.indexOf(userobj.email) > -1) || (this.settings.admins.indexOf(userobj.email) > -1);
      if (!rv) {
        domains = this.settings.domains.split(',');
        domains.forEach(function(domain) {
          if (userobj.email.indexOf(domain) > -1) {
            return rv = true;
          }
        });
      }
      if (this.settings.allowAnonymous) {
        rv = true;
      }
      return rv;
    };

    AuthenticationManager.prototype.isUserAdmin = function(userobj) {
      var rv;
      rv = this.settings.admins.indexOf(userobj.email) > -1;
      console.log('isUserAdmin user email is ' + userobj.email + ' admins are ' + this.settings.admins + ' rv = ' + rv);
      return rv;
    };

    AuthenticationManager.prototype.onLogoutUser = function(msg) {
      var sid;
      sid = msg.sessionId;
      if (sid) {
        delete this.activeUsers[msg.sessionId];
        console.log('removing user session for sid ' + sid);
        return msg.replyFunc({
          status: 'SUCCESS',
          info: 'user logged out',
          payload: sid
        });
      }
    };

    AuthenticationManager.prototype.setPublicGame = function(publicgame) {
      this.publicgame = publicgame;
    };

    AuthenticationManager.prototype.decorateMessageWithUser = function(message) {
      var q, user;
      console.log('decorateMessageWithUser for ' + message.sessionId);
      q = defer();
      if (message.sessionId) {
        user = this.activeUsers[message.sessionId];
        if (user) {
          console.log('decorateMessageWithUser found active user ' + user.name);
          message.user = user;
          q.resolve(message);
        } else {
          DB.findMany('QPUser', 'sessionId', message.sessionId).then((function(_this) {
            return function(urecords) {
              if (urecords && urecords[0]) {
                return DB.getFromStoreOrDB('QPUser', urecords[0].id).then(function(userobj) {
                  var ref;
                  message.user = userobj;
                  _this.activeUsers[message.sessionId] = userobj;
                  if (ref = userobj.email, indexOf.call(_this.admins, ref) >= 0) {
                    userobj.admin = true;
                  }
                  console.log('decorateMessageWithUser finding existing user ' + userobj.name + ' for sessionId ' + message.sessionId);
                  return q.resolve(message);
                });
              } else {
                return _this.getAnonymousUser(message).then(function(pl) {
                  return q.resolve(message);
                });
              }
            };
          })(this));
        }
      } else {
        this.getAnonymousUser(message).then((function(_this) {
          return function(pl) {
            return q.resolve(message);
          };
        })(this));
      }
      return q;
    };

    AuthenticationManager.prototype.getAnonymousUser = function(message) {
      var p, pl;
      p = defer();
      pl = this.anonymousUsers[message.client];
      if (pl) {
        message.user = pl;
        p.resolve(message);
      } else {
        console.log('* no existing player for client ' + message.client);
        new QPUser({
          name: 'Anonymous ' + uuid.v4()
        }).then((function(_this) {
          return function(pl) {
            console.log('decorating message with newly created player ' + pl.id + ' on client ' + message.client);
            pl.sid = uuid.v4();
            console.log('setting user sessionId to ' + pl.sid);
            pl.isAnonymous = true;
            message.user = pl;
            OStore.storeObject(pl);
            _this.activeUsers[pl.sid] = pl;
            _this.anonymousUsers[message.client] = pl;
            console.log(ClientEndpoints.endpoints);
            return p.resolve(message);
          };
        })(this));
      }
      return p;
    };

    AuthenticationManager.prototype.onDisconnect = function(adr) {
      var player;
      player = this.anonymousUsers[adr];
      if (player && player.isAnonymous) {
        console.log('onDisconnect got player ' + player.name + ' from disconnecting address ' + adr);
        return delete this.anonymousUsers[adr];
      }
    };

    AuthenticationManager.prototype.canUserReadFromThisObject = function(obj, user) {
      "#console.log 'canPlayerReadFromThisObject called obj = '+obj+' player = '+player.id+' obj.public = '+obj.public\n#console.dir obj\nmatch = (obj.createdBy is player.id) or obj.type == 'Thing' or obj.type == 'Game' or (obj.type == 'Team' and player.teamRef == obj.id)\n#if not match then match = obj.createdBy is player.id\n#console.log 'canPlayerReadFromThisObject match = '+match\nif not match then match = player.isAdmin\nreturn match";
      var rv;
      rv = this.allowUser(user);
      rv = obj.id === user.id;
      rv = obj.userRef === user.id;
      if (this.isUserAdmin(user)) {
        rv = true;
      }
      return rv;
    };

    AuthenticationManager.prototype.canUserWriteToThisObject = function(obj, user) {
      "match = obj.createdBy  is player.id\n#if not match then match = obj.createdBy is player.id\n#console.log 'canPlayerWriteToThisObject match = '+match\nif not match then match = player.isAdmin\nreturn match";
      var rv;
      rv = obj.id === user.id;
      rv = obj.userRef === user.id;
      if (this.isUserAdmin(user)) {
        rv = true;
      }
      return rv;
    };

    AuthenticationManager.prototype.canUserCreateThisObject = function(type, user) {
      var rv;
      if (this.isUserAdmin(user)) {
        rv = true;
      }
      return rv;
    };

    AuthenticationManager.prototype.canUserListTheseObjects = function(type, user) {
      var rv;
      if (this.isUserAdmin(user)) {
        rv = true;
      }
      return rv;
    };

    return AuthenticationManager;

  })();

  module.exports = AuthenticationManager;

}).call(this);

//# sourceMappingURL=AuthenticationManager.js.map
